import "./modulepreload-polyfill-B5Qt9EMX.js";/* empty css              *//* empty css              */import { f as ft, a as mt, b as pt, c as vt, s as gt } from "./supabaseClient-CuYTLnyz.js"; import { T as He } from "./top10data-3iuT5IqB.js"; function pe(e) { return !e || isNaN(e) ? "$0" : e >= 1e9 ? `$${(e / 1e9).toFixed(1)}B` : e >= 1e6 ? `$${(e / 1e6).toFixed(1)}M` : e >= 1e3 ? `$${(e / 1e3).toFixed(0)}K` : `$${e}` } function yt(e) { const t = e.length, s = e.reduce((i, o) => i + o.totalFunding, 0), n = e.length; return { totalStartups: t, totalBurned: pe(s), lootAvailable: n } } function Et() { const e = document.getElementById("hero-canvas"); if (!e) return; const t = e.getContext("2d"); let s, n, i = []; const o = () => { s = e.width = window.innerWidth, n = e.height = 600 }; window.addEventListener("resize", o), o(); class a { constructor() { this.init() } init() { this.x = Math.random() * s, this.y = n + Math.random() * 100, this.vx = (Math.random() - .5) * .5, this.vy = -(Math.random() * .5 + .2), this.size = Math.random() * 2 + 1, this.alpha = Math.random() * .5 + .2, this.life = Math.random() * .5 + .5, this.isResurrected = Math.random() > .8, this.color = this.isResurrected ? "rgba(255, 0, 150," : "rgba(255, 107, 0," } update() { this.x += this.vx, this.y += this.vy, this.life -= .002, (this.life <= 0 || this.y < 0) && this.init() } draw() { t.beginPath(), this.isResurrected ? (t.moveTo(this.x - this.size, this.y), t.lineTo(this.x + this.size, this.y), t.moveTo(this.x, this.y - this.size), t.lineTo(this.x, this.y + this.size), t.strokeStyle = `${this.color}${this.alpha * this.life})`, t.lineWidth = 1, t.stroke()) : (t.arc(this.x, this.y, this.size, 0, Math.PI * 2), t.fillStyle = `${this.color}${this.alpha * this.life})`, t.fill()) } } const r = () => { const u = Math.min(s / 10, 100); for (let f = 0; f < u; f++)i.push(new a) }, c = () => { t.clearRect(0, 0, s, n), i.forEach(u => { u.update(), u.draw() }), requestAnimationFrame(c) }; r(), c(); const l = document.getElementById("hero-title"); l && setInterval(() => { Math.random() > .95 && (l.classList.add("glitch"), setTimeout(() => l.classList.remove("glitch"), 200)) }, 1e3) } function Te(e) { return { high: 5, medium: 3, low: 1 }[e] || 3 } function At(e) { return e >= 300 ? "/icons/startup.png" : e >= 100 ? "/icons/profit.png" : "/icons/carrot-cultivation.png" } function ye(e, t) { const s = [], n = Math.min(4, Math.ceil(e / 5 * 4)); let i = ""; n >= 3 ? i = "high" : n === 2 ? i = "medium" : i = "low"; for (let o = 1; o <= 4; o++) { const a = o <= n; s.push(`<div class="card-v2-bar-block ${a ? "filled " + i : "empty"}"></div>`) } return s.join("") } function Ct(e, t = {}) {
    const { isBonfireTop: s = !1, viewedStartups: n = new Set } = t, i = s ? " bonfire-top" : "", o = Te(e.marketPotential), a = e.condensedValueProp || e.description?.substring(0, 147) + "..." || "A startup that failed to find product-market fit.", r = e.condensedCauseOfDeath || e.primaryCauseOfDeath || "Failed to execute on their vision.", l = n.has(e.id) ? " viewed" : "", u = "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'><path d='M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z'/><path d='m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z'/><path d='M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0'/><path d='M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5'/></svg>", f = "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'><path d='M7 22V12a5 5 0 0 1 10 0v10'/><path d='M10 16h4'/><path d='M10 12h4'/></svg>", m = "ğŸ’€", p = "ğŸ”¥", v = (e.name || "").toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, ""); return `
    <article class="startup-card-v2${i}${l}" data-id="${e.id}" data-slug="${v}">
      
      <!-- Header Bar (Yellow) -->
      <header class="card-v2-header">
        <div class="card-v2-header-left">
          <span class="card-v2-product-type">${(e.productType || "STARTUP").toUpperCase()}</span>
        </div>
        <!-- View Counter -->
        <div class="card-v2-views">
            <img src="${At(e.views || 0)}" class="card-v2-views-icon" alt="Views" />
            <span class="card-v2-views-count">${(e.views || 0).toLocaleString()}</span>
        </div>
      </header>

      <!-- Title Section -->
      <section class="card-v2-title-section">
        <h3 class="card-v2-name">${e.name}</h3>
        <span class="card-v2-country">\\${e.country || "Global"}</span>
        <div class="card-v2-funding-badge">
          <span class="card-v2-fire-icon">${p}</span>
          ${pe(e.totalFunding)}
        </div>
      </section>

      <!-- Value Proposition Section -->
      <section class="card-v2-content-section">
        <h4 class="card-v2-section-title">THE VALUE PROPOSITION</h4>
        <p class="card-v2-section-text">${a}</p>
        
        <div class="card-v2-dotted-divider"></div>
        
        <h4 class="card-v2-section-title">CAUSE OF DEATH</h4>
        <p class="card-v2-section-text">${r}</p>
      </section>

      <!-- Metrics Row (Rise/Fall) -->
      <section class="card-v2-metrics-section">
        <div class="card-v2-year-badges">
          <div class="card-v2-year-badge">
            <div class="card-v2-year-icon">${u}</div>
            <span class="card-v2-year-label">Rise</span>
            <div class="card-v2-year-value">${e.startYear || "????"}</div>
          </div>
          <div class="card-v2-year-badge">
            <div class="card-v2-year-icon">${f}</div>
            <span class="card-v2-year-label">Fall</span>
            <div class="card-v2-year-value">${e.endYear || "????"}</div>
          </div>
        </div>
      </section>

      <!-- Color-Coded Bars -->
      <section class="card-v2-bars-section">
        <div class="card-v2-bar-group">
          <span class="card-v2-bar-label">Market potential</span>
          <div class="card-v2-bar-blocks">
            ${ye(o)}
          </div>
        </div>
        <div class="card-v2-bar-group">
          <span class="card-v2-bar-label">Scale potential</span>
          <div class="card-v2-bar-blocks">
            ${ye(e.scalability || 3)}
          </div>
        </div>
        <div class="card-v2-bar-group">
          <span class="card-v2-bar-label">Rebuild potential</span>
          <div class="card-v2-bar-blocks">
            ${ye(e.difficulty || 3)}
          </div>
        </div>
      </section>

      <!-- Footer (Dark Red) -->
      <footer class="card-v2-footer">
        <div class="card-v2-footer-icon">${m}</div>
        <span class="card-v2-footer-text">${(e.primaryCauseOfDeath || "Unknown").toUpperCase()}</span>
      </footer>
    </article>
  `} var bt = "@vercel/analytics", Bt = "1.6.1", St = () => { window.va || (window.va = function (...t) { (window.vaq = window.vaq || []).push(t) }) }; function Je() { return typeof window < "u" } function Qe() { try { const e = "production" } catch { } return "production" } function wt(e = "auto") { if (e === "auto") { window.vam = Qe(); return } window.vam = e } function Lt() { return (Je() ? window.vam : Qe()) || "production" } function Be() { return Lt() === "development" } function Mt(e) { return e.scriptSrc ? e.scriptSrc : Be() ? "https://va.vercel-scripts.com/v1/script.debug.js" : e.basePath ? `${e.basePath}/insights/script.js` : "/_vercel/insights/script.js" } function It(e = { debug: !0 }) { var t; if (!Je()) return; wt(e.mode), St(), e.beforeSend && ((t = window.va) == null || t.call(window, "beforeSend", e.beforeSend)); const s = Mt(e); if (document.head.querySelector(`script[src*="${s}"]`)) return; const n = document.createElement("script"); n.src = s, n.defer = !0, n.dataset.sdkn = bt + (e.framework ? `/${e.framework}` : ""), n.dataset.sdkv = Bt, e.disableAutoTrack && (n.dataset.disableAutoTrack = "1"), e.endpoint ? n.dataset.endpoint = e.endpoint : e.basePath && (n.dataset.endpoint = `${e.basePath}/insights`), e.dsn && (n.dataset.dsn = e.dsn), n.onerror = () => { const i = Be() ? "Please check if any ad blockers are enabled and try again." : "Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information."; console.log(`[Vercel Web Analytics] Failed to load script from ${s}. ${i}`) }, Be() && e.debug === !1 && (n.dataset.debug = "false"), document.head.appendChild(n) } function I(e) { return Array.isArray ? Array.isArray(e) : et(e) === "[object Array]" } function kt(e) { if (typeof e == "string") return e; let t = e + ""; return t == "0" && 1 / e == -1 / 0 ? "-0" : t } function Ft(e) { return e == null ? "" : kt(e) } function w(e) { return typeof e == "string" } function Xe(e) { return typeof e == "number" } function $t(e) { return e === !0 || e === !1 || Dt(e) && et(e) == "[object Boolean]" } function Ze(e) { return typeof e == "object" } function Dt(e) { return Ze(e) && e !== null } function A(e) { return e != null } function Ee(e) { return !e.trim().length } function et(e) { return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e) } const xt = "Incorrect 'index' type", Tt = e => `Invalid value for key ${e}`, Rt = e => `Pattern length exceeds max of ${e}.`, Ot = e => `Missing ${e} property in key`, _t = e => `Property 'weight' in key '${e}' must be a positive integer`, je = Object.prototype.hasOwnProperty; class Pt { constructor(t) { this._keys = [], this._keyMap = {}; let s = 0; t.forEach(n => { let i = tt(n); this._keys.push(i), this._keyMap[i.id] = i, s += i.weight }), this._keys.forEach(n => { n.weight /= s }) } get(t) { return this._keyMap[t] } keys() { return this._keys } toJSON() { return JSON.stringify(this._keys) } } function tt(e) { let t = null, s = null, n = null, i = 1, o = null; if (w(e) || I(e)) n = e, t = Ue(e), s = Se(e); else { if (!je.call(e, "name")) throw new Error(Ot("name")); const a = e.name; if (n = a, je.call(e, "weight") && (i = e.weight, i <= 0)) throw new Error(_t(a)); t = Ue(a), s = Se(a), o = e.getFn } return { path: t, id: s, weight: i, src: n, getFn: o } } function Ue(e) { return I(e) ? e : e.split(".") } function Se(e) { return I(e) ? e.join(".") : e } function Nt(e, t) { let s = [], n = !1; const i = (o, a, r) => { if (A(o)) if (!a[r]) s.push(o); else { let c = a[r]; const l = o[c]; if (!A(l)) return; if (r === a.length - 1 && (w(l) || Xe(l) || $t(l))) s.push(Ft(l)); else if (I(l)) { n = !0; for (let u = 0, f = l.length; u < f; u += 1)i(l[u], a, r + 1) } else a.length && i(l, a, r + 1) } }; return i(e, w(t) ? t.split(".") : t, 0), n ? s : s[0] } const Ht = { includeMatches: !1, findAllMatches: !1, minMatchCharLength: 1 }, jt = { isCaseSensitive: !1, ignoreDiacritics: !1, includeScore: !1, keys: [], shouldSort: !0, sortFn: (e, t) => e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1 }, Ut = { location: 0, threshold: .6, distance: 100 }, Yt = { useExtendedSearch: !1, getFn: Nt, ignoreLocation: !1, ignoreFieldNorm: !1, fieldNormWeight: 1 }; var d = { ...jt, ...Ht, ...Ut, ...Yt }; const zt = /[^ ]+/g; function qt(e = 1, t = 3) { const s = new Map, n = Math.pow(10, t); return { get(i) { const o = i.match(zt).length; if (s.has(o)) return s.get(o); const a = 1 / Math.pow(o, .5 * e), r = parseFloat(Math.round(a * n) / n); return s.set(o, r), r }, clear() { s.clear() } } } class Re { constructor({ getFn: t = d.getFn, fieldNormWeight: s = d.fieldNormWeight } = {}) { this.norm = qt(s, 3), this.getFn = t, this.isCreated = !1, this.setIndexRecords() } setSources(t = []) { this.docs = t } setIndexRecords(t = []) { this.records = t } setKeys(t = []) { this.keys = t, this._keysMap = {}, t.forEach((s, n) => { this._keysMap[s.id] = n }) } create() { this.isCreated || !this.docs.length || (this.isCreated = !0, w(this.docs[0]) ? this.docs.forEach((t, s) => { this._addString(t, s) }) : this.docs.forEach((t, s) => { this._addObject(t, s) }), this.norm.clear()) } add(t) { const s = this.size(); w(t) ? this._addString(t, s) : this._addObject(t, s) } removeAt(t) { this.records.splice(t, 1); for (let s = t, n = this.size(); s < n; s += 1)this.records[s].i -= 1 } getValueForItemAtKeyId(t, s) { return t[this._keysMap[s]] } size() { return this.records.length } _addString(t, s) { if (!A(t) || Ee(t)) return; let n = { v: t, i: s, n: this.norm.get(t) }; this.records.push(n) } _addObject(t, s) { let n = { i: s, $: {} }; this.keys.forEach((i, o) => { let a = i.getFn ? i.getFn(t) : this.getFn(t, i.path); if (A(a)) { if (I(a)) { let r = []; const c = [{ nestedArrIndex: -1, value: a }]; for (; c.length;) { const { nestedArrIndex: l, value: u } = c.pop(); if (A(u)) if (w(u) && !Ee(u)) { let f = { v: u, i: l, n: this.norm.get(u) }; r.push(f) } else I(u) && u.forEach((f, m) => { c.push({ nestedArrIndex: m, value: f }) }) } n.$[o] = r } else if (w(a) && !Ee(a)) { let r = { v: a, n: this.norm.get(a) }; n.$[o] = r } } }), this.records.push(n) } toJSON() { return { keys: this.keys, records: this.records } } } function st(e, t, { getFn: s = d.getFn, fieldNormWeight: n = d.fieldNormWeight } = {}) { const i = new Re({ getFn: s, fieldNormWeight: n }); return i.setKeys(e.map(tt)), i.setSources(t), i.create(), i } function Vt(e, { getFn: t = d.getFn, fieldNormWeight: s = d.fieldNormWeight } = {}) { const { keys: n, records: i } = e, o = new Re({ getFn: t, fieldNormWeight: s }); return o.setKeys(n), o.setIndexRecords(i), o } function ie(e, { errors: t = 0, currentLocation: s = 0, expectedLocation: n = 0, distance: i = d.distance, ignoreLocation: o = d.ignoreLocation } = {}) { const a = t / e.length; if (o) return a; const r = Math.abs(n - s); return i ? a + r / i : r ? 1 : a } function Kt(e = [], t = d.minMatchCharLength) { let s = [], n = -1, i = -1, o = 0; for (let a = e.length; o < a; o += 1) { let r = e[o]; r && n === -1 ? n = o : !r && n !== -1 && (i = o - 1, i - n + 1 >= t && s.push([n, i]), n = -1) } return e[o - 1] && o - n >= t && s.push([n, o - 1]), s } const P = 32; function Wt(e, t, s, { location: n = d.location, distance: i = d.distance, threshold: o = d.threshold, findAllMatches: a = d.findAllMatches, minMatchCharLength: r = d.minMatchCharLength, includeMatches: c = d.includeMatches, ignoreLocation: l = d.ignoreLocation } = {}) { if (t.length > P) throw new Error(Rt(P)); const u = t.length, f = e.length, m = Math.max(0, Math.min(n, f)); let p = o, v = m; const E = r > 1 || c, b = E ? Array(f) : []; let k; for (; (k = e.indexOf(t, v)) > -1;) { let C = ie(t, { currentLocation: k, expectedLocation: m, distance: i, ignoreLocation: l }); if (p = Math.min(C, p), v = k + u, E) { let F = 0; for (; F < u;)b[k + F] = 1, F += 1 } } v = -1; let L = [], U = 1, O = u + f; const ht = 1 << u - 1; for (let C = 0; C < u; C += 1) { let F = 0, $ = O; for (; F < $;)ie(t, { errors: C, currentLocation: m + $, expectedLocation: m, distance: i, ignoreLocation: l }) <= p ? F = $ : O = $, $ = Math.floor((O - F) / 2 + F); O = $; let Pe = Math.max(1, m - $ + 1), ge = a ? f : Math.min(m + $, f) + u, Y = Array(ge + 2); Y[ge + 1] = (1 << C) - 1; for (let B = ge; B >= Pe; B -= 1) { let ne = B - 1, Ne = s[e.charAt(ne)]; if (E && (b[ne] = +!!Ne), Y[B] = (Y[B + 1] << 1 | 1) & Ne, C && (Y[B] |= (L[B + 1] | L[B]) << 1 | 1 | L[B + 1]), Y[B] & ht && (U = ie(t, { errors: C, currentLocation: ne, expectedLocation: m, distance: i, ignoreLocation: l }), U <= p)) { if (p = U, v = ne, v <= m) break; Pe = Math.max(1, 2 * m - v) } } if (ie(t, { errors: C + 1, currentLocation: m, expectedLocation: m, distance: i, ignoreLocation: l }) > p) break; L = Y } const ve = { isMatch: v >= 0, score: Math.max(.001, U) }; if (E) { const C = Kt(b, r); C.length ? c && (ve.indices = C) : ve.isMatch = !1 } return ve } function Gt(e) { let t = {}; for (let s = 0, n = e.length; s < n; s += 1) { const i = e.charAt(s); t[i] = (t[i] || 0) | 1 << n - s - 1 } return t } const he = String.prototype.normalize ? (e => e.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, "")) : (e => e); class nt { constructor(t, { location: s = d.location, threshold: n = d.threshold, distance: i = d.distance, includeMatches: o = d.includeMatches, findAllMatches: a = d.findAllMatches, minMatchCharLength: r = d.minMatchCharLength, isCaseSensitive: c = d.isCaseSensitive, ignoreDiacritics: l = d.ignoreDiacritics, ignoreLocation: u = d.ignoreLocation } = {}) { if (this.options = { location: s, threshold: n, distance: i, includeMatches: o, findAllMatches: a, minMatchCharLength: r, isCaseSensitive: c, ignoreDiacritics: l, ignoreLocation: u }, t = c ? t : t.toLowerCase(), t = l ? he(t) : t, this.pattern = t, this.chunks = [], !this.pattern.length) return; const f = (p, v) => { this.chunks.push({ pattern: p, alphabet: Gt(p), startIndex: v }) }, m = this.pattern.length; if (m > P) { let p = 0; const v = m % P, E = m - v; for (; p < E;)f(this.pattern.substr(p, P), p), p += P; if (v) { const b = m - P; f(this.pattern.substr(b), b) } } else f(this.pattern, 0) } searchIn(t) { const { isCaseSensitive: s, ignoreDiacritics: n, includeMatches: i } = this.options; if (t = s ? t : t.toLowerCase(), t = n ? he(t) : t, this.pattern === t) { let E = { isMatch: !0, score: 0 }; return i && (E.indices = [[0, t.length - 1]]), E } const { location: o, distance: a, threshold: r, findAllMatches: c, minMatchCharLength: l, ignoreLocation: u } = this.options; let f = [], m = 0, p = !1; this.chunks.forEach(({ pattern: E, alphabet: b, startIndex: k }) => { const { isMatch: L, score: U, indices: O } = Wt(t, E, b, { location: o + k, distance: a, threshold: r, findAllMatches: c, minMatchCharLength: l, includeMatches: i, ignoreLocation: u }); L && (p = !0), m += U, L && O && (f = [...f, ...O]) }); let v = { isMatch: p, score: p ? m / this.chunks.length : 1 }; return p && i && (v.indices = f), v } } class R { constructor(t) { this.pattern = t } static isMultiMatch(t) { return Ye(t, this.multiRegex) } static isSingleMatch(t) { return Ye(t, this.singleRegex) } search() { } } function Ye(e, t) { const s = e.match(t); return s ? s[1] : null } class Jt extends R { constructor(t) { super(t) } static get type() { return "exact" } static get multiRegex() { return /^="(.*)"$/ } static get singleRegex() { return /^=(.*)$/ } search(t) { const s = t === this.pattern; return { isMatch: s, score: s ? 0 : 1, indices: [0, this.pattern.length - 1] } } } class Qt extends R { constructor(t) { super(t) } static get type() { return "inverse-exact" } static get multiRegex() { return /^!"(.*)"$/ } static get singleRegex() { return /^!(.*)$/ } search(t) { const n = t.indexOf(this.pattern) === -1; return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] } } } class Xt extends R { constructor(t) { super(t) } static get type() { return "prefix-exact" } static get multiRegex() { return /^\^"(.*)"$/ } static get singleRegex() { return /^\^(.*)$/ } search(t) { const s = t.startsWith(this.pattern); return { isMatch: s, score: s ? 0 : 1, indices: [0, this.pattern.length - 1] } } } class Zt extends R { constructor(t) { super(t) } static get type() { return "inverse-prefix-exact" } static get multiRegex() { return /^!\^"(.*)"$/ } static get singleRegex() { return /^!\^(.*)$/ } search(t) { const s = !t.startsWith(this.pattern); return { isMatch: s, score: s ? 0 : 1, indices: [0, t.length - 1] } } } class es extends R { constructor(t) { super(t) } static get type() { return "suffix-exact" } static get multiRegex() { return /^"(.*)"\$$/ } static get singleRegex() { return /^(.*)\$$/ } search(t) { const s = t.endsWith(this.pattern); return { isMatch: s, score: s ? 0 : 1, indices: [t.length - this.pattern.length, t.length - 1] } } } class ts extends R { constructor(t) { super(t) } static get type() { return "inverse-suffix-exact" } static get multiRegex() { return /^!"(.*)"\$$/ } static get singleRegex() { return /^!(.*)\$$/ } search(t) { const s = !t.endsWith(this.pattern); return { isMatch: s, score: s ? 0 : 1, indices: [0, t.length - 1] } } } class it extends R { constructor(t, { location: s = d.location, threshold: n = d.threshold, distance: i = d.distance, includeMatches: o = d.includeMatches, findAllMatches: a = d.findAllMatches, minMatchCharLength: r = d.minMatchCharLength, isCaseSensitive: c = d.isCaseSensitive, ignoreDiacritics: l = d.ignoreDiacritics, ignoreLocation: u = d.ignoreLocation } = {}) { super(t), this._bitapSearch = new nt(t, { location: s, threshold: n, distance: i, includeMatches: o, findAllMatches: a, minMatchCharLength: r, isCaseSensitive: c, ignoreDiacritics: l, ignoreLocation: u }) } static get type() { return "fuzzy" } static get multiRegex() { return /^"(.*)"$/ } static get singleRegex() { return /^(.*)$/ } search(t) { return this._bitapSearch.searchIn(t) } } class ot extends R { constructor(t) { super(t) } static get type() { return "include" } static get multiRegex() { return /^'"(.*)"$/ } static get singleRegex() { return /^'(.*)$/ } search(t) { let s = 0, n; const i = [], o = this.pattern.length; for (; (n = t.indexOf(this.pattern, s)) > -1;)s = n + o, i.push([n, s - 1]); const a = !!i.length; return { isMatch: a, score: a ? 0 : 1, indices: i } } } const we = [Jt, ot, Xt, Zt, ts, es, Qt, it], ze = we.length, ss = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, ns = "|"; function is(e, t = {}) { return e.split(ns).map(s => { let n = s.trim().split(ss).filter(o => o && !!o.trim()), i = []; for (let o = 0, a = n.length; o < a; o += 1) { const r = n[o]; let c = !1, l = -1; for (; !c && ++l < ze;) { const u = we[l]; let f = u.isMultiMatch(r); f && (i.push(new u(f, t)), c = !0) } if (!c) for (l = -1; ++l < ze;) { const u = we[l]; let f = u.isSingleMatch(r); if (f) { i.push(new u(f, t)); break } } } return i }) } const os = new Set([it.type, ot.type]); class as { constructor(t, { isCaseSensitive: s = d.isCaseSensitive, ignoreDiacritics: n = d.ignoreDiacritics, includeMatches: i = d.includeMatches, minMatchCharLength: o = d.minMatchCharLength, ignoreLocation: a = d.ignoreLocation, findAllMatches: r = d.findAllMatches, location: c = d.location, threshold: l = d.threshold, distance: u = d.distance } = {}) { this.query = null, this.options = { isCaseSensitive: s, ignoreDiacritics: n, includeMatches: i, minMatchCharLength: o, findAllMatches: r, ignoreLocation: a, location: c, threshold: l, distance: u }, t = s ? t : t.toLowerCase(), t = n ? he(t) : t, this.pattern = t, this.query = is(this.pattern, this.options) } static condition(t, s) { return s.useExtendedSearch } searchIn(t) { const s = this.query; if (!s) return { isMatch: !1, score: 1 }; const { includeMatches: n, isCaseSensitive: i, ignoreDiacritics: o } = this.options; t = i ? t : t.toLowerCase(), t = o ? he(t) : t; let a = 0, r = [], c = 0; for (let l = 0, u = s.length; l < u; l += 1) { const f = s[l]; r.length = 0, a = 0; for (let m = 0, p = f.length; m < p; m += 1) { const v = f[m], { isMatch: E, indices: b, score: k } = v.search(t); if (E) { if (a += 1, c += k, n) { const L = v.constructor.type; os.has(L) ? r = [...r, ...b] : r.push(b) } } else { c = 0, a = 0, r.length = 0; break } } if (a) { let m = { isMatch: !0, score: c / a }; return n && (m.indices = r), m } } return { isMatch: !1, score: 1 } } } const Le = []; function rs(...e) { Le.push(...e) } function Me(e, t) { for (let s = 0, n = Le.length; s < n; s += 1) { let i = Le[s]; if (i.condition(e, t)) return new i(e, t) } return new nt(e, t) } const fe = { AND: "$and", OR: "$or" }, Ie = { PATH: "$path", PATTERN: "$val" }, ke = e => !!(e[fe.AND] || e[fe.OR]), cs = e => !!e[Ie.PATH], ls = e => !I(e) && Ze(e) && !ke(e), qe = e => ({ [fe.AND]: Object.keys(e).map(t => ({ [t]: e[t] })) }); function at(e, t, { auto: s = !0 } = {}) { const n = i => { let o = Object.keys(i); const a = cs(i); if (!a && o.length > 1 && !ke(i)) return n(qe(i)); if (ls(i)) { const c = a ? i[Ie.PATH] : o[0], l = a ? i[Ie.PATTERN] : i[c]; if (!w(l)) throw new Error(Tt(c)); const u = { keyId: Se(c), pattern: l }; return s && (u.searcher = Me(l, t)), u } let r = { children: [], operator: o[0] }; return o.forEach(c => { const l = i[c]; I(l) && l.forEach(u => { r.children.push(n(u)) }) }), r }; return ke(e) || (e = qe(e)), n(e) } function us(e, { ignoreFieldNorm: t = d.ignoreFieldNorm }) { e.forEach(s => { let n = 1; s.matches.forEach(({ key: i, norm: o, score: a }) => { const r = i ? i.weight : null; n *= Math.pow(a === 0 && r ? Number.EPSILON : a, (r || 1) * (t ? 1 : o)) }), s.score = n }) } function ds(e, t) { const s = e.matches; t.matches = [], A(s) && s.forEach(n => { if (!A(n.indices) || !n.indices.length) return; const { indices: i, value: o } = n; let a = { indices: i, value: o }; n.key && (a.key = n.key.src), n.idx > -1 && (a.refIndex = n.idx), t.matches.push(a) }) } function hs(e, t) { t.score = e.score } function fs(e, t, { includeMatches: s = d.includeMatches, includeScore: n = d.includeScore } = {}) { const i = []; return s && i.push(ds), n && i.push(hs), e.map(o => { const { idx: a } = o, r = { item: t[a], refIndex: a }; return i.length && i.forEach(c => { c(o, r) }), r }) } class J { constructor(t, s = {}, n) { this.options = { ...d, ...s }, this.options.useExtendedSearch, this._keyStore = new Pt(this.options.keys), this.setCollection(t, n) } setCollection(t, s) { if (this._docs = t, s && !(s instanceof Re)) throw new Error(xt); this._myIndex = s || st(this.options.keys, this._docs, { getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight }) } add(t) { A(t) && (this._docs.push(t), this._myIndex.add(t)) } remove(t = () => !1) { const s = []; for (let n = 0, i = this._docs.length; n < i; n += 1) { const o = this._docs[n]; t(o, n) && (this.removeAt(n), n -= 1, i -= 1, s.push(o)) } return s } removeAt(t) { this._docs.splice(t, 1), this._myIndex.removeAt(t) } getIndex() { return this._myIndex } search(t, { limit: s = -1 } = {}) { const { includeMatches: n, includeScore: i, shouldSort: o, sortFn: a, ignoreFieldNorm: r } = this.options; let c = w(t) ? w(this._docs[0]) ? this._searchStringList(t) : this._searchObjectList(t) : this._searchLogical(t); return us(c, { ignoreFieldNorm: r }), o && c.sort(a), Xe(s) && s > -1 && (c = c.slice(0, s)), fs(c, this._docs, { includeMatches: n, includeScore: i }) } _searchStringList(t) { const s = Me(t, this.options), { records: n } = this._myIndex, i = []; return n.forEach(({ v: o, i: a, n: r }) => { if (!A(o)) return; const { isMatch: c, score: l, indices: u } = s.searchIn(o); c && i.push({ item: o, idx: a, matches: [{ score: l, value: o, norm: r, indices: u }] }) }), i } _searchLogical(t) { const s = at(t, this.options), n = (r, c, l) => { if (!r.children) { const { keyId: f, searcher: m } = r, p = this._findMatches({ key: this._keyStore.get(f), value: this._myIndex.getValueForItemAtKeyId(c, f), searcher: m }); return p && p.length ? [{ idx: l, item: c, matches: p }] : [] } const u = []; for (let f = 0, m = r.children.length; f < m; f += 1) { const p = r.children[f], v = n(p, c, l); if (v.length) u.push(...v); else if (r.operator === fe.AND) return [] } return u }, i = this._myIndex.records, o = {}, a = []; return i.forEach(({ $: r, i: c }) => { if (A(r)) { let l = n(s, r, c); l.length && (o[c] || (o[c] = { idx: c, item: r, matches: [] }, a.push(o[c])), l.forEach(({ matches: u }) => { o[c].matches.push(...u) })) } }), a } _searchObjectList(t) { const s = Me(t, this.options), { keys: n, records: i } = this._myIndex, o = []; return i.forEach(({ $: a, i: r }) => { if (!A(a)) return; let c = []; n.forEach((l, u) => { c.push(...this._findMatches({ key: l, value: a[u], searcher: s })) }), c.length && o.push({ idx: r, item: a, matches: c }) }), o } _findMatches({ key: t, value: s, searcher: n }) { if (!A(s)) return []; let i = []; if (I(s)) s.forEach(({ v: o, i: a, n: r }) => { if (!A(o)) return; const { isMatch: c, score: l, indices: u } = n.searchIn(o); c && i.push({ score: l, key: t, value: o, idx: a, norm: r, indices: u }) }); else { const { v: o, n: a } = s, { isMatch: r, score: c, indices: l } = n.searchIn(o); r && i.push({ score: c, key: t, value: o, norm: a, indices: l }) } return i } } J.version = "7.1.0"; J.createIndex = st; J.parseIndex = Vt; J.config = d; J.parseQuery = at; rs(as); let S = [], H = [], D = "", Fe = null; function rt(e, t) { let s; return function (...i) { const o = () => { clearTimeout(s), e(...i) }; clearTimeout(s), s = setTimeout(o, t) } } let h = { sector: "", year: null, difficulty: null, scalability: null, market: "", country: "", primaryCause: "", productType: "", sort: "default" }, oe = new Set(JSON.parse(localStorage.getItem("viewedStartups") || "[]")); const ms = 100; let N = 0, ce = 0, $e = !1; const x = document.getElementById("cards-grid"), me = document.getElementById("no-results"), K = document.getElementById("modal-overlay"); document.getElementById("modal"); const ct = document.getElementById("modal-content"), ps = document.getElementById("modal-close"), De = document.getElementById("search-input"), vs = document.getElementById("total-startups"), gs = document.getElementById("total-burned"), X = document.getElementById("sector-select"), Z = document.getElementById("cause-select"), ee = document.getElementById("product-type-select"), T = document.getElementById("year-select"), z = document.getElementById("difficulty-select"), q = document.getElementById("scalability-select"), te = document.getElementById("market-select"), j = document.getElementById("country-select"), Ve = document.getElementById("reset-all"), Ke = document.getElementById("open-request-bucket"), We = document.getElementById("close-request-bucket"), V = document.getElementById("request-modal-overlay"), se = document.getElementById("request-form"), _ = document.getElementById("request-status"), ae = document.getElementById("back-to-top"), M = document.getElementById("main-sidebar"), W = document.getElementById("hamburger-btn"), Ge = document.getElementById("sidebar-close"), G = document.getElementById("drawer-overlay"), re = document.getElementById("filter-tree"), Ae = document.getElementById("top10-tree"); let le = new Set(["sector"]), ue = new Set; async function ys() {
    try { It(), x.innerHTML = '<div class="loading">Resurrecting the dead...</div>'; const [e, t] = await Promise.all([ft(), mt()]); if (e.error) throw new Error("List Error: " + JSON.stringify(e.error)); S = e.data || [], ce = S.length; const s = t.count || 0; H = [...S], Fe = new J(S, { keys: [{ name: "name", weight: 2 }, { name: "condensedValueProp", weight: 1 }, { name: "condensedCauseOfDeath", weight: 1 }, { name: "description", weight: .8 }, { name: "sector", weight: .7 }, { name: "productType", weight: .7 }, { name: "primaryCauseOfDeath", weight: .5 }, { name: "country", weight: .3 }], threshold: .3, ignoreLocation: !0, minMatchCharLength: 2, includeScore: !0 }), console.log(`[Fuse.js] Search index built for ${S.length} startups`), Es(s), bs(), Cs(), N = 0, Oe(), Ds(), Ss(), Rs(), ws(), Ms(), Et(), lt() } catch (e) {
        console.error("Init failed:", e), x.innerHTML = `<div class="no-results" style="display:block; color:red;">
      CRITICAL ERROR IN GRAVEYARD:<br>
      ${e.message}<br><br>
      Checking fetchStartupsList...
    </div>`}
} function Es(e = null) { As(vs, ce); const t = e ? pe(e) : yt(S).totalBurned; gs.textContent = t; const s = document.getElementById("hero-badge"), n = document.getElementById("total-startups"), i = document.getElementById("total-burned"); s && (s.textContent = `ğŸ’€ OVER ${ce} DEAD STARTUPS`), n && (n.textContent = ce.toLocaleString()), i && (i.textContent = t + "+") } function As(e, t) { let s = 0; const n = Math.ceil(t / 30), i = setInterval(() => { s += n, s >= t && (s = t, clearInterval(i)), e.textContent = s.toLocaleString() }, 30) } function y() { let e = [...S]; if (D && D.trim().length > 0 && Fe && (e = Fe.search(D.trim()).filter(s => s.score < .35).map(s => s.item)), h.sector && (e = e.filter(t => t.sector === h.sector)), h.year !== null && (e = e.filter(t => t.endYear === h.year)), h.difficulty !== null && (e = e.filter(t => t.difficulty === h.difficulty)), h.scalability !== null && (e = e.filter(t => t.scalability === h.scalability)), h.market && (h.market === "high" || h.market, e = e.filter(t => { const s = Te(t.marketPotential); return h.market === "high" ? s >= 4 : h.market === "medium" ? s === 3 : s <= 2 })), h.country && (e = e.filter(t => t.country === h.country)), h.primaryCause && (e = e.filter(t => t.primaryCauseOfDeath === h.primaryCause)), h.productType && (e = e.filter(t => t.productType === h.productType)), !D || D.trim().length === 0) switch (h.sort) { case "burned": e.sort((t, s) => (s.totalFunding || 0) - (t.totalFunding || 0)); break; case "recent": e.sort((t, s) => (s.endYear || 0) - (t.endYear || 0)); break; case "bonfire": e.sort((t, s) => (s.totalFunding || 0) - (t.totalFunding || 0)), e = e.slice(0, 10); break }if (H = e, H.length === 0) { x.innerHTML = '<div id="no-results" class="no-results" style="display: block;">No corpses found matching your criteria.</div>', me.style.display = "block"; return } me.style.display = "none", N = 0, Oe(!1) } async function Cs() { if (!j) return; const { data: e, error: t } = await pt(); if (t || !e) { console.error("Failed to fetch countries for filter"); return } const s = { USA: "ğŸ‡ºğŸ‡¸", UK: "ğŸ‡¬ğŸ‡§", Germany: "ğŸ‡©ğŸ‡ª", France: "ğŸ‡«ğŸ‡·", Canada: "ğŸ‡¨ğŸ‡¦", Australia: "ğŸ‡¦ğŸ‡º", India: "ğŸ‡®ğŸ‡³", China: "ğŸ‡¨ğŸ‡³", Japan: "ğŸ‡¯ğŸ‡µ", Israel: "ğŸ‡®ğŸ‡±", Brazil: "ğŸ‡§ğŸ‡·", Netherlands: "ğŸ‡³ğŸ‡±", Singapore: "ğŸ‡¸ğŸ‡¬", Sweden: "ğŸ‡¸ğŸ‡ª", Switzerland: "ğŸ‡¨ğŸ‡­", Spain: "ğŸ‡ªğŸ‡¸", Italy: "ğŸ‡®ğŸ‡¹", Ireland: "ğŸ‡®ğŸ‡ª", Denmark: "ğŸ‡©ğŸ‡°", Finland: "ğŸ‡«ğŸ‡®", Norway: "ğŸ‡³ğŸ‡´", Belgium: "ğŸ‡§ğŸ‡ª", "South Korea": "ğŸ‡°ğŸ‡·", Mexico: "ğŸ‡²ğŸ‡½", Argentina: "ğŸ‡¦ğŸ‡·", Chile: "ğŸ‡¨ğŸ‡±", Colombia: "ğŸ‡¨ğŸ‡´", Nigeria: "ğŸ‡³ğŸ‡¬", Kenya: "ğŸ‡°ğŸ‡ª", Ghana: "ğŸ‡¬ğŸ‡­", Vietnam: "ğŸ‡»ğŸ‡³", Indonesia: "ğŸ‡®ğŸ‡©", Malaysia: "ğŸ‡²ğŸ‡¾", Turkey: "ğŸ‡¹ğŸ‡·", Russia: "ğŸ‡·ğŸ‡º", Ukraine: "ğŸ‡ºğŸ‡¦", Estonia: "ğŸ‡ªğŸ‡ª", Lithuania: "ğŸ‡±ğŸ‡¹", Iceland: "ğŸ‡®ğŸ‡¸" }; j.innerHTML = '<option value="">ğŸŒ COUNTRY</option>' + e.map(n => { const i = s[n] || "ğŸ³ï¸"; return `<option value="${n}">${i} ${n.toUpperCase()}</option>` }).join("") } function bs() { if (!T || S.length === 0) return; const e = [...new Set(S.map(t => t.endYear).filter(t => t))].sort((t, s) => s - t); T.innerHTML = '<option value="">ğŸ“… DEATH YEAR</option>' + e.map(t => `<option value="${t}">${t}</option>`).join("") } function Bs() { h = { sector: "", year: null, difficulty: null, scalability: null, market: "", country: "", primaryCause: "", productType: "", sort: "default" }, De.value = "", D = "", X && (X.value = ""), Z && (Z.value = ""), ee && (ee.value = ""), T && (T.value = ""), z && (z.value = ""), q && (q.value = ""), te && (te.value = ""), j && (j.value = ""), document.querySelectorAll(".sort-btn").forEach(e => { e.classList.toggle("active", e.dataset.sort === "default") }), y() } function Ss() { X && X.addEventListener("change", () => { h.sector = X.value, y() }), Z && Z.addEventListener("change", () => { h.primaryCause = Z.value, y() }), ee && ee.addEventListener("change", () => { h.productType = ee.value, y() }), T && T.addEventListener("change", () => { h.year = T.value ? parseInt(T.value) : null, y() }), z && z.addEventListener("change", () => { h.difficulty = z.value ? parseInt(z.value) : null, y() }), q && q.addEventListener("change", () => { h.scalability = q.value ? parseInt(q.value) : null, y() }), te && te.addEventListener("change", () => { h.market = te.value, y() }), j && j.addEventListener("change", () => { h.country = j.value, y() }), document.querySelectorAll(".sort-btn").forEach(i => { i.addEventListener("click", () => { h.sort = i.dataset.sort, document.querySelectorAll(".sort-btn").forEach(o => o.classList.remove("active")), i.classList.add("active"), y() }) }), Ve && Ve.addEventListener("click", Bs); const e = document.getElementById("toggle-filters"), t = document.getElementById("filter-row"); e && t && e.addEventListener("click", () => { const i = t.classList.toggle("expanded"); e.classList.toggle("active"); const o = e.querySelector(".toggle-icon"); o && (o.textContent = i ? "â–²" : "â–¼") }); const s = document.getElementById("toggle-sort"), n = document.getElementById("sort-row"); s && n && s.addEventListener("click", () => { const i = n.classList.toggle("expanded"); s.classList.toggle("active"); const o = s.querySelector(".toggle-icon"); o && (o.textContent = i ? "â–²" : "â–¼") }) } function Oe(e = !1) { if (H.length === 0) { x.innerHTML = "", me.style.display = "block"; return } me.style.display = "none", e || (N = 0, x.innerHTML = ""); const t = N, s = Math.min(N + ms, H.length), i = H.slice(t, s).map((a, r) => { const c = h.sort === "bonfire" && t + r < 10; return Ct(a, { isBonfireTop: c, viewedStartups: oe }) }).join(""); x.insertAdjacentHTML("beforeend", i), N = s, x.querySelectorAll(".startup-card:not([data-listener]), .startup-card-v2:not([data-listener])").forEach(a => { a.setAttribute("data-listener", "true"); const r = a.querySelector(".share-btn-card"); r && r.addEventListener("click", c => { c.stopPropagation(); const l = r.dataset.slug, u = `${window.location.origin}/startup/${l}`; ut(r, u) }), a.addEventListener("click", async c => { if (c.target.closest(".score-item") || c.target.closest(".share-btn-card")) return; const l = parseInt(a.dataset.id), u = a.dataset.slug || ""; oe.has(l) || (oe.add(l), localStorage.setItem("viewedStartups", JSON.stringify(Array.from(oe))), a.classList.add("viewed")), window.location.href = `/startup/${l}-${u}` }) }), $e = !1 } function ws() { const e = document.createElement("div"); e.id = "scroll-sentinel", e.style.height = "1px", x.parentNode.appendChild(e), new IntersectionObserver(s => { s.forEach(n => { if (!n.isIntersecting || $e) return; N < H.length && ($e = !0, Oe(!0)) }) }, { rootMargin: "200px" }).observe(e) } function Ls(e) { ct.innerHTML = ks(e), K.classList.add("active"), document.body.classList.add("modal-open") } function Ce() { K.classList.remove("active"), document.body.classList.remove("modal-open"), window.location.pathname !== "/" && (history.pushState(null, "", "/"), document.title = "Loot Drop | 1100+ Failed Startup Case Studies & Ideas to Steal") } async function lt() { const t = window.location.pathname.match(/^\/startup\/(\d+)/); if (t) { const s = parseInt(t[1]), { data: n } = await vt(s); n && Ls(n) } } function Ms() { window.addEventListener("popstate", e => { const t = window.location.pathname; t === "/" ? (K.classList.remove("active"), document.body.classList.remove("modal-open"), document.title = "Loot Drop | 1100+ Failed Startup Case Studies & Ideas to Steal") : t.startsWith("/startup/") && lt() }) } function Is() { return '<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>' } function ks(e) {
    const t = { media: "MEDIA", health: "HEALTH", social: "SOCIAL", hardware: "HARDWARE", ecommerce: "E-COMMERCE", crypto: "CRYPTO", ondemand: "ON-DEMAND", fintech: "FINTECH" }, s = Te(e.marketPotential); return `
    <header class="modal-header">
      <div class="modal-title-row">
        <h2 class="modal-company-name">${e.name}</h2>
        <button class="share-btn" id="share-btn" title="Copy Link">${Is()}</button>
      </div>
      <div class="modal-meta">
        <span class="modal-years">${e.startYear} â€” ${e.endYear}</span>
        <span class="modal-burned">${pe(e.totalFunding)} BURNED</span>
        <span class="modal-category">${t[e.sector] || e.sector || "UNKNOWN"}</span>
      </div>
    </header>
    
    <section class="modal-section value-prop-section">
      <div class="section-header">
        <span class="section-icon">ğŸ’¡</span>
        <h3 class="section-title">The Value Proposition</h3>
      </div>
      <div class="section-content">
        <p class="value-prop-text">${e.description}</p>
      </div>
    </section>
    
    <section class="modal-section">
      <div class="section-header">
        <span class="section-icon">ğŸ“Š</span>
        <h3 class="section-title">Opportunity Score</h3>
      </div>
      <div class="section-content">
        <div class="modal-scores">
          <div class="modal-score-item">
            <div class="modal-score-label">ğŸ”§ Rebuild Difficulty</div>
            ${be(e.difficulty, 5, e.difficulty >= 4 ? "hard" : e.difficulty >= 3 ? "medium" : "")}
            <div class="modal-score-value">${e.difficulty}/5 ${Fs(e.difficulty)}</div>
            <div class="modal-score-tooltip">${e.difficultyReason}</div>
          </div>
          <div class="modal-score-item">
            <div class="modal-score-label">ğŸ“ˆ Scalability Potential</div>
            ${be(e.scalability, 5, "")}
            <div class="modal-score-value">${e.scalability}/5 ${$s(e.scalability)}</div>
            <div class="modal-score-tooltip">${e.scalabilityReason}</div>
          </div>
          <div class="modal-score-item">
            <div class="modal-score-label">ğŸ¯ Market Potential Today</div>
            ${be(s, 5, e.marketPotential === "low" ? "hard" : e.marketPotential === "medium" ? "medium" : "")}
            <div class="modal-score-value">${e.marketPotential.toUpperCase()}</div>
            <div class="modal-score-tooltip">${e.marketPotentialReason}</div>
          </div>
        </div>
      </div>
    </section>
    
    <section class="modal-section">
      <div class="section-header">
        <span class="section-icon">âš°ï¸</span>
        <h3 class="section-title">Cause of Death</h3>
      </div>
      <div class="section-content">
        <p>${e.causeOfDeath}</p>
      </div>
    </section>
    
    <section class="modal-section loot-section">
      <div class="section-header">
        <span class="section-icon">ğŸ’</span>
        <h3 class="section-title">The Loot</h3>
      </div>
      <div class="section-content">
        <ul>
          ${e.theLoot.map(n => `<li>${n}</li>`).join("")}
        </ul>
      </div>
    </section>
    
    <section class="modal-section">
      <div class="section-header">
        <span class="section-icon">ğŸ‘¥</span>
        <h3 class="section-title">Key People & Investors</h3>
      </div>
      <div class="section-content">
        <div class="people-grid">
          ${e.founders.map(n => `
            <div class="person-card">
              <div class="person-role">Founder</div>
              <div class="person-name">${n}</div>
            </div>
          `).join("")}
          ${e.investors.map(n => `
            <div class="person-card">
              <div class="person-role">Investor</div>
              <div class="person-name">${n}</div>
            </div>
          `).join("")}
        </div>
      </div>
    </section>
    
    <section class="modal-section">
      <div class="section-header">
        <span class="section-icon">ğŸ“ˆ</span>
        <h3 class="section-title">Market Today</h3>
      </div>
      <div class="section-content">
        <p>${e.marketAnalysis}</p>
      </div>
    </section>
    
    <section class="modal-section pivot-section">
      <div class="section-header">
        <span class="section-icon">ğŸ”„</span>
        <h3 class="section-title">The New Business Idea & Product Name</h3>
      </div>
      <div class="section-content">
        <h4 class="pivot-name">${e.pivotIdea.name}</h4>
        <p>${e.pivotIdea.concept}</p>
        <div class="tech-stack">
          ${e.pivotIdea.techStack.map(n => `<span class="tech-tag">${n}</span>`).join("")}
        </div>
      </div>
    </section>
    
    <section class="modal-section execution-section">
      <div class="section-header">
        <span class="section-icon">ğŸš€</span>
        <h3 class="section-title">Execution Plan</h3>
      </div>
      <div class="section-content">
        <ul class="step-list">
          ${e.pivotIdea.mvpSteps.map(n => `<li>${n}</li>`).join("")}
        </ul>
        <div class="monetization">
          <div class="monetization-title">ğŸ’° Monetization Strategy</div>
          <p>${e.pivotIdea.monetization}</p>
        </div>
      </div>
    </section>
  `} function be(e, t = 5, s = "") { const n = []; for (let i = 1; i <= t; i++) { let o = ""; i <= e && (o = "filled", s && (o += " " + s)), n.push(`<span class="${o}"></span>`) } return `<div class="modal-score-bar">${n.join("")}</div>` } function Fs(e) { return e <= 2 ? "(Easy)" : e <= 3 ? "(Moderate)" : e <= 4 ? "(Hard)" : "(Expert)" } function $s(e) { return e <= 2 ? "(Limited)" : e <= 3 ? "(Moderate)" : e <= 4 ? "(High)" : "(Infinite)" } function Ds() { if (De) { const e = rt(() => { y() }, 300); De.addEventListener("input", t => { D = t.target.value, e() }) } ps.addEventListener("click", Ce), K.addEventListener("click", e => { e.target === K && Ce() }), document.addEventListener("keydown", e => { e.key === "Escape" && K.classList.contains("active") && Ce(), e.key === "Escape" && V.classList.contains("active") && de() }), Ke && Ke.addEventListener("click", xs), We && We.addEventListener("click", de), V && V.addEventListener("click", e => { e.target === V && de() }), se && se.addEventListener("submit", Ts), ct.addEventListener("click", e => { e.target.closest(".share-btn") && ut(e.target.closest(".share-btn"), window.location.href) }), ae && (ae.addEventListener("click", () => { window.scrollTo({ top: 0, behavior: "smooth" }) }), window.addEventListener("scroll", () => { window.scrollY > 300 ? ae.classList.add("visible") : ae.classList.remove("visible") })) } async function ut(e, t) { try { await navigator.clipboard.writeText(t); const s = e.innerHTML; e.innerHTML = '<span style="font-size: 0.6em; font-weight: bold;">COPIED!</span>', e.classList.add("copied"), setTimeout(() => { e.innerHTML = s, e.classList.remove("copied") }, 2e3) } catch (s) { console.error("Failed to copy class", s) } } function xs() { V.classList.add("active"), document.body.classList.add("modal-open") } function de() { V.classList.remove("active"), document.body.classList.remove("modal-open"), _.style.display = "none", se.reset() } async function Ts(e) { e.preventDefault(); const t = se.querySelector('button[type="submit"]'), s = document.getElementById("request-type").value, n = document.getElementById("request-content").value, i = document.getElementById("request-email").value; t.disabled = !0, t.textContent = "BURYING..."; const { error: o } = await gt({ type: s, content: n, email: i, created_at: new Date().toISOString() }); t.disabled = !1, t.textContent = "BURY THE GOODS", o ? (console.error("Submission error:", o), _.textContent = "âŒ ERROR: THE BUCKET IS FULL. TRY LATER.", _.className = "request-status error", _.style.display = "block") : (_.textContent = "âœ… SUCCESS: YOUR LOOT HAS BEEN BURIED.", _.className = "request-status success", _.style.display = "block", se.reset(), setTimeout(de, 3e3)) } const xe = [{ id: "sector", name: "SECTOR", icon: "ğŸ·ï¸", options: ["Information Technology", "Financials", "Health Care", "Communication Services", "Consumer", "Industrials", "Real Estate", "Materials", "Energy", "Utilities"] }, { id: "cause", name: "CAUSE OF DEATH", icon: "âš°ï¸", options: ["No Market Need", "Ran Out of Cash", "Team/Founder Conflict", "Competition", "Product/Tech Failure", "Legal/Regulatory", "Unit Economics"] }, { id: "productType", name: "PRODUCT TYPE", icon: "ğŸ› ï¸", options: ["SaaS (B2B)", "SaaS (B2C)", "Mobile App", "Developer Tools", "AI", "Interactive", "Blockchain/Crypto", "Marketplace", "Social Media", "EdTech", "Medical", "Wearables", "Robotics", "Consumer Electronics", "Biotech", "Personal Care", "Financial & Fintech", "CleanTech", "Hardware", "Aerospace", "Browser Extension", "IoT", "Cybersecurity"] }, { id: "year", name: "DEATH YEAR", icon: "ğŸ“…", options: [], dynamic: !0 }, { id: "difficulty", name: "REBUILD DIFFICULTY", icon: "ğŸ”§", options: ["1 - Easy", "2 - Moderate", "3 - Medium", "4 - Hard", "5 - Expert"] }, { id: "scalability", name: "SCALABILITY", icon: "ğŸ“ˆ", options: ["1 - Limited", "2 - Low", "3 - Medium", "4 - High", "5 - Massive"] }, { id: "market", name: "MARKET POTENTIAL", icon: "ğŸŒ", options: ["low", "medium", "high"] }, { id: "country", name: "COUNTRY", icon: "ğŸŒ", options: [], dynamic: !0 }]; let g = { sector: [], cause: [], productType: [], year: [], difficulty: [], scalability: [], market: [], country: [] }; function Rs() { M && (Os(), _e(), dt(), Hs(), js(), Us()) } function Os() { const e = [...new Set(S.map(i => i.endYear).filter(i => i))].sort((i, o) => o - i), t = xe.find(i => i.id === "year"); t && (t.options = e.map(i => String(i))); const s = [...new Set(S.map(i => i.country).filter(i => i))].sort(), n = xe.find(i => i.id === "country"); n && (n.options = s) } function _e() {
    if (!re) return; let e = ""; xe.forEach(t => {
        const s = le.has(t.id); e += `
      <div class="filter-category">
        <button class="filter-category-header ${s ? "expanded" : ""}" data-category-id="${t.id}">
          <span class="category-icon">${t.icon}</span>
          <span class="category-name">${t.name}</span>
          <span class="expand-icon">â–¼</span>
        </button>
        <div class="filter-options ${s ? "expanded" : ""}">
          ${t.options.map(n => `
              <div class="filter-option ${g[t.id]?.includes(n) ? "selected" : ""}" data-filter-type="${t.id}" data-value="${n}">
                <div class="filter-checkbox"></div>
                <span class="filter-option-label">${n}</span>
              </div>
            `).join("")}
        </div>
      </div>
    `}), re.innerHTML = e, re.querySelectorAll(".filter-category-header").forEach(t => { t.addEventListener("click", () => { const s = t.dataset.categoryId; _s(s) }) }), re.querySelectorAll(".filter-option").forEach(t => { t.addEventListener("click", () => { const s = t.dataset.filterType, n = t.dataset.value; Ps(s, n) }) })
} function _s(e) { le.has(e) ? le.delete(e) : le.add(e), _e() } function Ps(e, t) { g[e] || (g[e] = []); const s = g[e].indexOf(t); s > -1 ? g[e].splice(s, 1) : g[e].push(t), h.sector = g.sector[0] || "", h.primaryCause = g.cause[0] || "", h.productType = g.productType[0] || "", g.year[0] ? h.year = parseInt(g.year[0]) : h.year = null, g.difficulty[0] ? h.difficulty = parseInt(g.difficulty[0].split(" ")[0]) : h.difficulty = null, g.scalability[0] ? h.scalability = parseInt(g.scalability[0].split(" ")[0]) : h.scalability = null, h.market = g.market[0] || "", h.country = g.country[0] || "", _e(), y() } function dt() {
    if (!Ae || !He) return; let e = ""; He.categories.forEach(t => {
        const s = ue.has(t.id), n = s ? "ğŸ“‚" : "ğŸ“"; e += `
      <div class="top10-category">
        <button class="top10-category-header ${s ? "expanded" : ""}" data-category-id="${t.id}">
          <span class="folder-emoji">${n}</span>
          <span class="category-name">${t.name}</span>
          <span class="expand-icon">â–¼</span>
        </button>
        <div class="top10-category-items ${s ? "expanded" : ""}">
          ${t.lists.map(i => `
            <a href="/lists.html#${i.id}" class="top10-list-item">
              <span class="list-icon">${i.icon || "ğŸ“„"}</span>
              <span class="list-name">${i.name}</span>
            </a>
          `).join("")}
        </div>
      </div>
    `}), Ae.innerHTML = e, Ae.querySelectorAll(".top10-category-header").forEach(t => { t.addEventListener("click", () => { const s = t.dataset.categoryId; Ns(s) }) })
} function Ns(e) { ue.has(e) ? ue.delete(e) : ue.add(e), dt() } function Hs() { const e = document.querySelectorAll(".sidebar-sort-btn"); e.forEach(t => { t.addEventListener("click", () => { const s = t.dataset.sort; h.sort = s, e.forEach(n => n.classList.remove("active")), t.classList.add("active"), document.querySelectorAll(".sort-pill").forEach(n => { n.classList.toggle("active", n.dataset.sort === s) }), y(), Q() }) }) } function js() { const e = document.getElementById("search-bar-container"), t = document.getElementById("search-bar-label"), s = document.getElementById("search-input"); if (e && t && s) { e.addEventListener("click", () => { e.classList.add("active"), s.focus() }), s.addEventListener("blur", () => { s.value.trim() || e.classList.remove("active") }); const i = rt(() => { D = s.value, y() }, 300); s.addEventListener("input", i) } const n = document.querySelectorAll(".sort-pill"); n.forEach(i => { i.addEventListener("click", () => { const o = i.dataset.sort; h.sort = o, n.forEach(a => a.classList.remove("active")), i.classList.add("active"), document.querySelectorAll(".sidebar-sort-btn").forEach(a => { a.classList.toggle("active", a.dataset.sort === o) }), y() }) }) } function Us() { W && W.addEventListener("click", () => { M && M.classList.contains("open") ? Q() : Ys() }), Ge && Ge.addEventListener("click", Q), G && G.addEventListener("click", Q), document.addEventListener("keydown", e => { e.key === "Escape" && M && M.classList.contains("open") && Q() }) } function Ys() { M && M.classList.add("open"), G && G.classList.add("active"), W && W.classList.add("active"), document.body.style.overflow = "hidden" } function Q() { M && M.classList.remove("open"), G && G.classList.remove("active"), W && W.classList.remove("active"), document.body.style.overflow = "" } ys();
